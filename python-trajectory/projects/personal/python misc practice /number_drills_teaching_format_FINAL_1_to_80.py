# Python Numbers Drill Set — Complete (1–80)

# DRILL 1 — Number Seeds
# Goal: Create a variable with a number
# Why: To store values for future use
# How: Use = with a number
apples = 4  # Assigning value to 'apples'
print(apples)  # 4  # Displaying the result/output

# DRILL 2 — Number Seeds
# Goal: Create two variables with numbers
# Why: To represent multiple data points
# How: Use = for each variable
bananas = 7  # Assigning value to 'bananas'
oranges = 3  # Assigning value to 'oranges'
print(bananas, oranges)  # 7 3  # Displaying the result/output

# DRILL 3 — Number Seeds
# Goal: Create a placeholder variable
# Why: To store totals later
# How: Assign 0 to a variable
total_fruit = 0  # Assigning value to 'total_fruit'
print(total_fruit)  # 0  # Displaying the result/output

# DRILL 4 — Number Seeds
# Goal: Create a float variable
# Why: To work with decimals
# How: Use a number with .
basket_weight = 12.5  # Assigning value to 'basket_weight'
print(basket_weight)  # 12.5  # Displaying the result/output

# DRILL 5 — Number Seeds
# Goal: Create a variable with a large integer
# Why: To represent large values
# How: Use a big number
grape_count = 1000000  # Assigning value to 'grape_count'
print(grape_count)  # 1000000  # Displaying the result/output

# DRILL 6 — Printing & Tracing
# Goal: Print a single variable
# Why: To see stored values
# How: Use print(var)
print(apples)  # 4 or current value  # Displaying the result/output

# DRILL 7 — Printing & Tracing
# Goal: Print two variables on the same line
# Why: To display multiple values
# How: Use print(var1, var2)
print(bananas, oranges)  # 7 3  # Displaying the result/output

# DRILL 8 — Printing & Tracing
# Goal: Print a label with a number
# Why: To make output readable
# How: Use print('label', var)
grape_count = 1000000  # Assigning value to 'grape_count'
print("Grapes:", grape_count)  # Grapes: 1000000  # Displaying the result/output

# DRILL 9 — Printing & Tracing
# Goal: Print a float with a label
# Why: To format real-number output
# How: Use string + float
basket_weight = 12.5  # Assigning value to 'basket_weight'
print("Weight (kg):", basket_weight)  # Displaying the result/output

# DRILL 10 — Printing & Tracing
# Goal: Print a sentence using variables
# Why: To create readable outputs
# How: Combine strings and variables
print("There are", apples, "apples and", oranges, "oranges.")  # Displaying the result/output

# DRILL 11 — Number Types
# Goal: Assign a float and print
# Why: To observe float usage
# How: Assign 2.0
watermelons = 2.0  # Assigning value to 'watermelons'
print(watermelons)  # Displaying the result/output

# DRILL 12 — Number Types
# Goal: Compare int and float visually
# Why: To notice type difference
# How: Assign int and float, then print
whole_number = 10  # Assigning value to 'whole_number'
decimal = 10.0  # Assigning value to 'decimal'
print(whole_number)  # Displaying the result/output
print(decimal)  # Displaying the result/output

# DRILL 13 — Number Types
# Goal: Use type() to check types
# Why: To understand Python’s classification
# How: Use print(type(var))
print(type(whole_number))  # Displaying the result/output
print(type(decimal))  # Displaying the result/output

# DRILL 14 — Number Types
# Goal: Check the type of a float
# Why: To confirm float classification
# How: Use type()
pi_estimate = 3.14  # Assigning value to 'pi_estimate'
print(type(pi_estimate))  # Displaying the result/output

# DRILL 15 — Number Types
# Goal: Check the type of 0
# Why: To confirm zero is an int
# How: Use type(0)
zero_number = 0  # Assigning value to 'zero_number'
print(type(zero_number))  # Displaying the result/output

# DRILL 16 — Simple Arithmetic
# Goal: Add two variables
# Why: To combine numeric values
# How: Use + operator
sum_result = apples + oranges  # Assigning value to 'sum_result'
print(sum_result)  # Displaying the result/output

# DRILL 17 — Simple Arithmetic
# Goal: Subtract two variables
# Why: To find a difference
# How: Use - operator
difference = apples - oranges  # Assigning value to 'difference'
print(difference)  # Displaying the result/output

# DRILL 18 — Simple Arithmetic
# Goal: Multiply two variables
# Why: To scale values
# How: Use * operator
product = apples * oranges  # Assigning value to 'product'
print(product)  # Displaying the result/output

# DRILL 19 — Simple Arithmetic
# Goal: Divide two variables
# Why: To find a ratio
# How: Use / operator
quotient = oranges / apples  # Assigning value to 'quotient'
print(quotient)  # Displaying the result/output

# DRILL 20 — Simple Arithmetic
# Goal: Multiply a variable by 2
# Why: To double a value
# How: Use * 2
double_apples = apples * 2  # Assigning value to 'double_apples'
print(double_apples)  # Displaying the result/output

# DRILL 21 — Order of Operations
# Goal: Evaluate an expression with + and *
# Why: To understand Python's operator precedence
# How: Use normal math rules
result1 = 2 + 3 * 4  # Assigning value to 'result1'
print(result1)  # 14  # Displaying the result/output

# DRILL 22 — Order of Operations
# Goal: Add parentheses to control order
# Why: To override default precedence
# How: Use ( )
result2 = (2 + 3) * 4  # Assigning value to 'result2'
print(result2)  # 20  # Displaying the result/output

# DRILL 23 — Order of Operations
# Goal: Combine multiple operations
# Why: To see full PEMDAS in action
# How: Mix +, -, *, /
value = 10 + 6 / 2 * 3  # Assigning value to 'value'
print(value)  # 19.0  # Displaying the result/output

# DRILL 24 — Order of Operations
# Goal: Add grouping to an expression
# Why: To change how values are computed
# How: Use nested ( )
value = (10 + 6) / (2 * 3)  # Assigning value to 'value'
print(value)  # 2.666...  # Displaying the result/output

# DRILL 25 — Order of Operations
# Goal: Test precedence with all operators
# Why: To master order rules
# How: Use +, -, *, /
check = 5 + 2 * 3 - 1 / 2  # Assigning value to 'check'
print(check)  # 10.5  # Displaying the result/output

# DRILL 26 — Grouping with Parentheses
# Goal: Force addition before multiplication
# Why: To learn expression grouping
# How: Use (2 + 3) * 4
grouped = (2 + 3) * 4  # Assigning value to 'grouped'
print(grouped)  # 20  # Displaying the result/output

# DRILL 27 — Grouping with Parentheses
# Goal: Nest parentheses inside parentheses
# Why: To handle layered operations
# How: Use ( (a + b) * c )
value = ((1 + 2) * (3 + 4))  # Assigning value to 'value'
print(value)  # 21  # Displaying the result/output

# DRILL 28 — Grouping with Parentheses
# Goal: Use parentheses in a long expression
# Why: To increase clarity
# How: Group key parts
value = (10 - 2) * (4 + 1)  # Assigning value to 'value'
print(value)  # 40  # Displaying the result/output

# DRILL 29 — Grouping with Parentheses
# Goal: Override subtraction order
# Why: To control negative results
# How: Use (a - b)
forced = (3 - 5) * 2  # Assigning value to 'forced'
print(forced)  # -4  # Displaying the result/output

# DRILL 30 — Grouping with Parentheses
# Goal: Combine float and int with grouping
# Why: To test mixed type math
# How: Group floats and ints
value = (2.5 + 2.5) * 2  # Assigning value to 'value'
print(value)  # 10.0  # Displaying the result/output

# DRILL 31 — Reassignments
# Goal: Change a variable's value
# Why: To update data based on new input or result
# How: Use = to overwrite existing value
apples = 4  # Assigning initial value to 'apples'  # Assigning value to 'apples'
apples = 6  # Reassigning 'apples' with a new value  # Assigning value to 'apples'
print(apples)  # Displaying the updated value  # Displaying the result/output

# DRILL 32 — Reassignments
# Goal: Reassign a variable using a calculation
# Why: To update a value based on itself
# How: Use math with same variable
oranges = 10  # Initial value  # Assigning value to 'oranges'
oranges = oranges + 5  # Add 5 more oranges  # Assigning value to 'oranges'
print(oranges)  # Should print 15  # Displaying the result/output

# DRILL 33 — Reassignments
# Goal: Reassign a float value
# Why: To simulate updated measurements
# How: Assign new decimal to same variable
basket_weight = 12.5  # Assigning value to 'basket_weight'
basket_weight = 14.75  # New weight  # Assigning value to 'basket_weight'
print(basket_weight)  # Displaying the result/output

# DRILL 34 — Reassignments
# Goal: Store intermediate results with reassignment
# Why: To track progress or stages
# How: Use reassign to store new total
total_fruit = apples + oranges  # Assigning value to 'total_fruit'
apples = 7  # Updated count  # Assigning value to 'apples'
total_fruit = apples + oranges  # Assigning value to 'total_fruit'
print(total_fruit)  # Displaying the result/output

# DRILL 35 — Reassignments
# Goal: Reset a variable to zero
# Why: To start over or clear a value
# How: Use = 0
grape_count = 500  # Assigning value to 'grape_count'
grape_count = 0  # Resetting to empty  # Assigning value to 'grape_count'
print(grape_count)  # Displaying the result/output

# DRILL 36 — Precision & Rounding
# Goal: Round a float to nearest whole number
# Why: To simplify output or display
# How: Use round()
pi_estimate = 3.14  # Assigning value to 'pi_estimate'
rounded_pi = round(pi_estimate)  # Rounds to 3  # Assigning value to 'rounded_pi'
print(rounded_pi)  # Displaying the result/output

# DRILL 37 — Precision & Rounding
# Goal: Round a float to one decimal place
# Why: To control precision in display
# How: Use round(number, places)
avg_weight = 3.276  # Assigning value to 'avg_weight'
print(round(avg_weight, 1))  # 3.3  # Displaying the result/output

# DRILL 38 — Precision & Rounding
# Goal: Limit decimal output manually
# Why: To present cleaner numbers
# How: Use round() before assigning
exact_value = 12.8765  # Assigning value to 'exact_value'
clean_value = round(exact_value, 2)  # Assigning value to 'clean_value'
print(clean_value)  # Displaying the result/output

# DRILL 39 — Precision & Rounding
# Goal: Print a float with default precision
# Why: To observe normal float output
# How: Use float variable and print
length = 7.923456  # Assigning value to 'length'
print(length)  # Full float shown  # Displaying the result/output

# DRILL 40 — Precision & Rounding
# Goal: Use float result from division
# Why: To test how float appears after math
# How: Use / and observe decimal result
fraction = 5 / 2  # Assigning value to 'fraction'
print(fraction)  # 2.5  # Displaying the result/output

# DRILL 41 — Modulo & Division
# Goal: Use modulo to find a remainder
# Why: To check divisibility or cycle values
# How: Use % operator
remainder = 10 % 3  # 10 divided by 3 leaves remainder 1  # Assigning value to 'remainder'
print(remainder)  # Displaying the result/output

# DRILL 42 — Modulo & Division
# Goal: Check if a number is even
# Why: To build logic on number properties
# How: Even if num % 2 == 0
number = 8  # Assigning value to 'number'
even_check = number % 2  # Assigning value to 'even_check'
print(even_check)  # 0 means even  # Displaying the result/output

# DRILL 43 — Modulo & Division
# Goal: Divide and show float result
# Why: To practice float output with /
# How: Use division directly
quotient = 7 / 2  # Assigning value to 'quotient'
print(quotient)  # 3.5  # Displaying the result/output

# DRILL 44 — Modulo & Division
# Goal: Combine division and modulo
# Why: To split and track leftovers
# How: Use // and %
total = 17  # Assigning value to 'total'
whole = total // 5  # 3  # Assigning value to 'whole'
left = total % 5  # 2  # Assigning value to 'left'
print(whole, left)  # Displaying the result/output

# DRILL 45 — Modulo & Division
# Goal: Use modulo with large numbers
# Why: To observe pattern remainders
# How: Test % with big integers
large = 1001  # Assigning value to 'large'
print(large % 100)  # 1  # Displaying the result/output

# DRILL 46 — Negatives & Signs
# Goal: Assign a negative number
# Why: To track losses or deductions
# How: Use - before value
loss = -5  # Assigning value to 'loss'
print(loss)  # Displaying the result/output

# DRILL 47 — Negatives & Signs
# Goal: Subtract to get negative result
# Why: To test downward difference
# How: Subtract larger from smaller
a = 3  # Assigning value to 'a'
b = 7  # Assigning value to 'b'
diff = a - b  # Assigning value to 'diff'
print(diff)  # -4  # Displaying the result/output

# DRILL 48 — Negatives & Signs
# Goal: Multiply a number by -1
# Why: To invert a sign
# How: Use -1 multiplier
score = 9  # Assigning value to 'score'
flipped = score * -1  # Assigning value to 'flipped'
print(flipped)  # Displaying the result/output

# DRILL 49 — Negatives & Signs
# Goal: Add a negative to a positive
# Why: To simulate a loss or removal
# How: Use - inside addition
total = 10  # Assigning value to 'total'
update = total + (-3)  # Assigning value to 'update'
print(update)  # 7  # Displaying the result/output

# DRILL 50 — Negatives & Signs
# Goal: Use multiple negatives
# Why: To observe sign flips
# How: Multiply negative * negative
value = -4 * -2  # Assigning value to 'value'
print(value)  # 8  # Displaying the result/output

# DRILL 51 — Type Conversion
# Goal: Convert int to float
# Why: To prepare for decimal math
# How: Use float()
count = 7  # Assigning value to 'count'
converted = float(count)  # Assigning value to 'converted'
print(converted)  # Displaying the result/output

# DRILL 52 — Type Conversion
# Goal: Convert float to int
# Why: To remove decimals
# How: Use int()
length = 5.9  # Assigning value to 'length'
truncated = int(length)  # Assigning value to 'truncated'
print(truncated)  # Displaying the result/output

# DRILL 53 — Type Conversion
# Goal: Add int and float
# Why: To mix types safely
# How: Let Python auto-convert
result = 3 + 2.5  # Assigning value to 'result'
print(result)  # 5.5  # Displaying the result/output

# DRILL 54 — Type Conversion
# Goal: Check type after conversion
# Why: To confirm result class
# How: Use type()
n = 4  # Assigning value to 'n'
converted = float(n)  # Assigning value to 'converted'
print(type(converted))  # Displaying the result/output

# DRILL 55 — Type Conversion
# Goal: Divide ints, store as float
# Why: To see result type
# How: Use / operator
value = 9 / 3  # Assigning value to 'value'
print(type(value))  # Displaying the result/output

# DRILL 56 — Repetition Patterns
# Goal: Multiply a number to create repetition
# Why: To repeat values like units or scores
# How: Use * with numbers
stars = 3 * 5  # Assigning value to 'stars'
print(stars)  # 15  # Displaying the result/output

# DRILL 57 — Repetition Patterns
# Goal: Add a number multiple times
# Why: To simulate loops without loops
# How: Use chained addition
total = 2 + 2 + 2  # Assigning value to 'total'
print(total)  # 6  # Displaying the result/output

# DRILL 58 — Repetition Patterns
# Goal: Create a scaled value
# Why: To multiply a base amount
# How: Use variable * multiplier
base = 4  # Assigning value to 'base'
scaled = base * 6  # Assigning value to 'scaled'
print(scaled)  # Displaying the result/output

# DRILL 59 — Repetition Patterns
# Goal: Simulate stacking weight
# Why: To model added layers
# How: Multiply decimal by count
layer_weight = 1.5  # Assigning value to 'layer_weight'
total_weight = layer_weight * 4  # Assigning value to 'total_weight'
print(total_weight)  # Displaying the result/output

# DRILL 60 — Repetition Patterns
# Goal: Test odd count pattern
# Why: To verify odd steps
# How: Use % 2 on looped count
count = 11  # Assigning value to 'count'
print(count % 2)  # 1 (odd)  # Displaying the result/output

# DRILL 61 — Identity & Equality
# Goal: Compare two numbers for equality
# Why: To test if values match
# How: Use ==
a = 10  # Assigning value to 'a'
b = 10  # Assigning value to 'b'
print(a == b)  # True  # Displaying the result/output

# DRILL 62 — Identity & Equality
# Goal: Compare int and float
# Why: To explore loose vs strict equality
# How: Use == with mixed types
print(10 == 10.0)  # True  # Displaying the result/output

# DRILL 63 — Identity & Equality
# Goal: Compare numbers for inequality
# Why: To detect differences
# How: Use !=
a = 5  # Assigning value to 'a'
b = 7  # Assigning value to 'b'
print(a != b)  # True  # Displaying the result/output

# DRILL 64 — Identity & Equality
# Goal: Use > and <
# Why: To evaluate number size
# How: Use relational operators
print(3 < 7)  # True  # Displaying the result/output

# DRILL 65 — Identity & Equality
# Goal: Combine comparisons
# Why: To chain logic
# How: Use and/or with ==, >
x = 4  # Assigning value to 'x'
y = 4  # Assigning value to 'y'
print(x == y and x < 10)  # Displaying the result/output

# DRILL 66 — Simple Increments
# Goal: Add one to a variable
# Why: To step forward
# How: Use += 1
count = 1  # Assigning value to 'count'
count += 1  # Performing calculation or logic
print(count)  # 2  # Displaying the result/output

# DRILL 67 — Simple Increments
# Goal: Subtract using -=
# Why: To step back
# How: Use -=
stock = 10  # Assigning value to 'stock'
stock -= 2  # Performing calculation or logic
print(stock)  # 8  # Displaying the result/output

# DRILL 69 — Simple Increments
# Goal: Divide using /=
# Why: To reduce gradually
# How: Use /=
balance = 20  # Assigning value to 'balance'
balance /= 4  # Performing calculation or logic
print(balance)  # 5.0  # Displaying the result/output

# DRILL 70 — Simple Increments
# Goal: Chain += over multiple lines
# Why: To simulate accumulation
# How: Use += repeatedly
total = 0  # Assigning value to 'total'
total += 2  # Performing calculation or logic
total += 3  # Performing calculation or logic
print(total)  # 5  # Displaying the result/output

# DRILL 71 — Number Chains
# Goal: Combine multiple operations
# Why: To build more complex math
# How: Use chained arithmetic
result = 2 + 3 * 4 - 1  # Assigning value to 'result'
print(result)  # 13  # Displaying the result/output

# DRILL 72 — Number Chains
# Goal: Use parentheses in a chain
# Why: To control flow
# How: Mix + and * with grouping
value = (2 + 3) * (4 - 1)  # Assigning value to 'value'
print(value)  # 15  # Displaying the result/output

# DRILL 73 — Number Chains
# Goal: Mix float and int in chain
# Why: To see precision pass through
# How: Chain with float start
output = 2.5 + 3 * 2  # Assigning value to 'output'
print(output)  # 8.5  # Displaying the result/output

# DRILL 74 — Number Chains
# Goal: Include negative in chain
# Why: To confirm math direction
# How: Use - in complex math
calc = -2 + 4 * 3  # Assigning value to 'calc'
print(calc)  # 10  # Displaying the result/output

# DRILL 75 — Number Chains
# Goal: Store result in a variable
# Why: To preserve output
# How: Assign chain to variable
final = (5 + 5) * 2  # Assigning value to 'final'
print(final)  # 20  # Displaying the result/output

# DRILL 76 — Rich Composition
# Goal: Nest expressions deeply
# Why: To layer number logic
# How: Use multiple levels of ( )
value = ((2 + 3) * (4 + 1)) - 2  # Assigning value to 'value'
print(value)  # 23  # Displaying the result/output

# DRILL 77 — Rich Composition
# Goal: Chain += and math
# Why: To track updates
# How: Use math inside increment
score = 10  # Assigning value to 'score'
score += 3 * 2  # Performing calculation or logic
print(score)  # 16  # Displaying the result/output

# DRILL 78 — Rich Composition
# Goal: Compare result from expression
# Why: To test math outcome
# How: Use == with a chain
check = (2 + 3) * 2 == 10  # Assigning value to 'check'
print(check)  # True  # Displaying the result/output

# DRILL 79 — Rich Composition
# Goal: Store float after math
# Why: To confirm float output
# How: Mix / and *
amount = 9 / 2 * 1.5  # Assigning value to 'amount'
print(amount)  # 6.75  # Displaying the result/output

# DRILL 80 — Rich Composition
# Goal: Use grouped and mixed types
# Why: To handle complex structure
# How: Combine int and float with grouping
value = (3 + 4.0) * 2  # Assigning value to 'value'
print(value)  # 14.0  # Displaying the result/output

# DRILL 56 — Repetition Patterns
# Goal: Multiply a number to create repetition
# Why: To repeat values like units or scores
# How: Use * with numbers
stars = 3 * 5  # Assigning value to 'stars'
print(stars)  # 15  # Displaying the result/output

# DRILL 57 — Repetition Patterns
# Goal: Add a number multiple times
# Why: To simulate loops without loops
# How: Use chained addition
total = 2 + 2 + 2  # Assigning value to 'total'
print(total)  # 6  # Displaying the result/output

# DRILL 58 — Repetition Patterns
# Goal: Create a scaled value
# Why: To multiply a base amount
# How: Use variable * multiplier
base = 4  # Assigning value to 'base'
scaled = base * 6  # Assigning value to 'scaled'
print(scaled)  # Displaying the result/output

# DRILL 59 — Repetition Patterns
# Goal: Simulate stacking weight
# Why: To model added layers
# How: Multiply decimal by count
layer_weight = 1.5  # Assigning value to 'layer_weight'
total_weight = layer_weight * 4  # Assigning value to 'total_weight'
print(total_weight)  # Displaying the result/output

# DRILL 60 — Repetition Patterns
# Goal: Test odd count pattern
# Why: To verify odd steps
# How: Use % 2 on looped count
count = 11  # Assigning value to 'count'
print(count % 2)  # 1 (odd)  # Displaying the result/output

# DRILL 61 — Identity & Equality
# Goal: Compare two numbers for equality
# Why: To test if values match
# How: Use ==
a = 10  # Assigning value to 'a'
b = 10  # Assigning value to 'b'
print(a == b)  # True  # Displaying the result/output

# DRILL 62 — Identity & Equality
# Goal: Compare int and float
# Why: To explore loose vs strict equality
# How: Use == with mixed types
print(10 == 10.0)  # True  # Displaying the result/output

# DRILL 63 — Identity & Equality
# Goal: Compare numbers for inequality
# Why: To detect differences
# How: Use !=
a = 5  # Assigning value to 'a'
b = 7  # Assigning value to 'b'
print(a != b)  # True  # Displaying the result/output

# DRILL 64 — Identity & Equality
# Goal: Use > and <
# Why: To evaluate number size
# How: Use relational operators
print(3 < 7)  # True  # Displaying the result/output

# DRILL 65 — Identity & Equality
# Goal: Combine comparisons
# Why: To chain logic
# How: Use and/or with ==, >
x = 4  # Assigning value to 'x'
y = 4  # Assigning value to 'y'
print(x == y and x < 10)  # Displaying the result/output

# DRILL 66 — Simple Increments
# Goal: Add one to a variable
# Why: To step forward
# How: Use += 1
count = 1  # Assigning value to 'count'
count += 1  # Performing calculation or logic
print(count)  # 2  # Displaying the result/output

# DRILL 67 — Simple Increments
# Goal: Subtract using -=
# Why: To step back
# How: Use -=
stock = 10  # Assigning value to 'stock'
stock -= 2  # Performing calculation or logic
print(stock)  # 8  # Displaying the result/output

# DRILL 68 — Simple Increments
# Goal: Multiply using *=
# Why: To scale up
# How: Use correct operator
price = 4  # Assigning value to 'price'
price *= 3  # Performing calculation or logic
print(price)  # 12  # Displaying the result/output

# DRILL 69 — Simple Increments
# Goal: Divide using /=
# Why: To reduce gradually
# How: Use /=
balance = 20  # Assigning value to 'balance'
balance /= 4  # Performing calculation or logic
print(balance)  # 5.0  # Displaying the result/output

# DRILL 70 — Simple Increments
# Goal: Chain += over multiple lines
# Why: To simulate accumulation
# How: Use += repeatedly
total = 0  # Assigning value to 'total'
total += 2  # Performing calculation or logic
total += 3  # Performing calculation or logic
print(total)  # 5  # Displaying the result/output

# DRILL 71 — Number Chains
# Goal: Combine multiple operations
# Why: To build more complex math
# How: Use chained arithmetic
result = 2 + 3 * 4 - 1  # Assigning value to 'result'
print(result)  # 13  # Displaying the result/output

# DRILL 72 — Number Chains
# Goal: Use parentheses in a chain
# Why: To control flow
# How: Mix + and * with grouping
value = (2 + 3) * (4 - 1)  # Assigning value to 'value'
print(value)  # 15  # Displaying the result/output

# DRILL 73 — Number Chains
# Goal: Mix float and int in chain
# Why: To see precision pass through
# How: Chain with float start
output = 2.5 + 3 * 2  # Assigning value to 'output'
print(output)  # 8.5  # Displaying the result/output

# DRILL 74 — Number Chains
# Goal: Include negative in chain
# Why: To confirm math direction
# How: Use - in complex math
calc = -2 + 4 * 3  # Assigning value to 'calc'
print(calc)  # 10  # Displaying the result/output

# DRILL 75 — Number Chains
# Goal: Store result in a variable
# Why: To preserve output
# How: Assign chain to variable
final = (5 + 5) * 2  # Assigning value to 'final'
print(final)  # 20  # Displaying the result/output

# DRILL 76 — Rich Composition
# Goal: Nest expressions deeply
# Why: To layer number logic
# How: Use multiple levels of ( )
value = ((2 + 3) * (4 + 1)) - 2  # Assigning value to 'value'
print(value)  # 23  # Displaying the result/output

# DRILL 77 — Rich Composition
# Goal: Chain += and math
# Why: To track updates
# How: Use math inside increment
score = 10  # Assigning value to 'score'
score += 3 * 2  # Performing calculation or logic
print(score)  # 16  # Displaying the result/output

# DRILL 78 — Rich Composition
# Goal: Compare result from expression
# Why: To test math outcome
# How: Use == with a chain
check = (2 + 3) * 2 == 10  # Assigning value to 'check'
print(check)  # True  # Displaying the result/output

# DRILL 79 — Rich Composition
# Goal: Store float after math
# Why: To confirm float output
# How: Mix / and *
amount = 9 / 2 * 1.5  # Assigning value to 'amount'
print(amount)  # 6.75  # Displaying the result/output

# DRILL 80 — Rich Composition
# Goal: Use grouped and mixed types
# Why: To handle complex structure
# How: Combine int and float with grouping
value = (3 + 4.0) * 2  # Assigning value to 'value'
print(value)  # 14.0  # Displaying the result/output
